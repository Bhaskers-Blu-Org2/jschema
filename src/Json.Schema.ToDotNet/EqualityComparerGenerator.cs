// Copyright (c) Microsoft Corporation.  All Rights Reserved.
// Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Globalization;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Microsoft.Json.Schema.ToDotNet
{
    /// <summary>
    /// Generates classes that implement <see cref="System.Collections.Generic.IEqualityComparer{T}"/>.
    /// </summary>
    internal class EqualityComparerGenerator
    {
        private const string EqualityComparerSuffix = "EqualityComparer";
        private const string EqualityComparerInterfaceName = "I" + EqualityComparerSuffix;

        private const string FirstEqualsAgumentName = "left";
        private const string SecondEqualsArgumentName = "right";
        private const string GetHashCodeArgumentName = "obj";

        private readonly string _copyrightNotice;
        private readonly string _namespaceName;

        private string _className;
        private TypeSyntax _classType;

        /// <summary>
        /// Initializes a new instance of the <see cref="EqualityComparerGenerator"/> class.
        /// </summary>
        /// <param name="copyrightNotice">
        /// The copyright notice to display at the top of the file, or null if there is
        /// no copyright notice.
        /// </param>
        /// <param name="namespaceName">
        /// The name of the namespace into which the classes generated by this object
        /// are to be placed.
        /// </param>
        internal EqualityComparerGenerator(
            string copyrightNotice,
            string namespaceName)
        {
            _copyrightNotice = copyrightNotice;
            _namespaceName = namespaceName;
        }

        /// <summary>
        /// Gets a string containing the name of the equality comparer class generated by
        /// the most recent class to <see cref="Generate(string, PropertyInfoDictionary)"/>.
        /// </summary>
        internal static string GetEqualityComparerClassName(string className)
        {
            return className + EqualityComparerSuffix;
        }

        /// <summary>
        /// Generates a class that implements <see cref="System.Collections.Generic.IEqualityComparer{T}"/>
        /// for the specified class.
        /// </summary>
        /// <param name="className">
        /// The name of the class whose equality comparer class is to be generated.
        /// </param>
        /// <param name="propertyInfoDictionary">
        /// An object containing information about each property in the class specified by <paramref name="className"/>.
        /// </param>
        /// <returns>
        /// A string containing the text of the generated equality comparer class.
        /// </returns>
        internal string Generate(string className, PropertyInfoDictionary propertyInfoDictionary)
        {
            _className = className;
            _classType = SyntaxFactory.ParseTypeName(_className);

            string comparerClassName = GetEqualityComparerClassName(_className);

            var comparerInterface = MakeComparerBaseType();

            ClassDeclarationSyntax classDeclaration =
                SyntaxFactory.ClassDeclaration(comparerClassName)
                    .AddModifiers(
                        SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                        SyntaxFactory.Token(SyntaxKind.SealedKeyword))
                    .AddBaseListTypes(comparerInterface)
                    .AddMembers(
                        GenerateEqualsMethod(),
                        GenerateGetHashCodeMethod());

            var usings = new List<string>();

            return classDeclaration.Format(
                _copyrightNotice,
                usings,
                _namespaceName,
                MakeSummaryComment());
        }

        private BaseTypeSyntax MakeComparerBaseType()
        {
            return SyntaxFactory.SimpleBaseType(
                SyntaxFactory.GenericName(
                    SyntaxFactory.Identifier(EqualityComparerInterfaceName),
                    SyntaxFactory.TypeArgumentList(SyntaxFactory.SeparatedList(
                        new TypeSyntax[] {
                            SyntaxFactory.ParseTypeName(_className)
                        }))));
        }

        private string MakeSummaryComment()
        {
            return string.Format(
                CultureInfo.CurrentCulture,
                Resources.EqualityComparerSummary,
                _className);
        }

        private MemberDeclarationSyntax GenerateEqualsMethod()
        {
            return SyntaxFactory.MethodDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.BoolKeyword)),
                "Equals")
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(FirstEqualsAgumentName))
                        .WithType(_classType),
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(SecondEqualsArgumentName))
                        .WithType(_classType))
                .AddBodyStatements();
        }

        private MemberDeclarationSyntax GenerateGetHashCodeMethod()
        {
            return SyntaxFactory.MethodDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.IntKeyword)),
                "GetHashCode")
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddParameterListParameters(
                    SyntaxFactory.Parameter(
                        SyntaxFactory.Identifier(GetHashCodeArgumentName))
                        .WithType(_classType))
                .AddBodyStatements();
        }
    }
}
